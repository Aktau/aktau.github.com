<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="utf-8">

        <title>A makefile for modern C programming on UNIX-like operating systems</title>

        <link rel="stylesheet" href="/style.css">
        <link rel="stylesheet" href="/stylesheets/pygments.css">

        <meta name="description" content="Presents a (hopefully) understandable makefile that can be used for cross-platform, cross-compiler projects in C/C++">
        <meta name="keywords" content="unix, c, make, linux, osx">
        <meta name="author" content="Nicolas Hillegeer">
        <meta name="generator" content="nanoc 3.6.7">
    </head>
    <body>
        <div id="main">
    <div class="post">
        <h1>A makefile for modern C programming on UNIX-like operating systems</h1>
        <aside>August 7, 2013</aside>

        <article>
            <p>Looking for an easy to use build tool? Project not yet large enough to warrant cmake? Downright scared of autotools (which generates the scariest kind of makefiles)? May I present… make!</p>

<!-- more -->

<p>Most of you have probably seen what a makefile looks like, either from another open source project or automatically generated by tools like <a href="http://orwelldevcpp.blogspot.de/">Dev-C++</a> <sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup> or (god forbid) autotools. They usually have one thing in common: <strong>they’re horrendous, unreadable messes</strong>. And it makes you never want to touch make with a 10-foot pole.</p>

<p>It was just recently that I learned that it didn’t have to be that way, make can be small and simple. Let’s start with the simplest of makefiles, which compiles a single .c file into an application. Save the following into a file with the name Makefile, next to a main.c file. <sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup></p>

<pre><code class="language-make"><span class="nf">myapp</span><span class="o">:</span> <span class="m">main.c</span>
    gcc -o myapp main.c -I.</code></pre>

<p>To run it, execute:</p>

<pre><code class="language-bash"><span class="nv">$ </span>make myapp
<span class="c"># or... absent a specific target, make will</span>
<span class="c"># just execute the first one it finds.</span>
<span class="nv">$ </span>make</code></pre>

<p>(if you get strange errors when you try this, it’s because you haven’t been indenting your lines with a TAB-character. Make explicitly requires that lines be indented with tabs or it will throw a hissy fit and spout poorly worded error messages from which it is impossible to infer that it actually wants tabs.)</p>

<p>So, what does this do? Make will try to run gcc in the following cases:</p>

<ul>
<li>the file <em>myapp</em> DOES NOT exist and all dependencies are present</li>
  <li>the file <em>myapp</em> DOES exist and all dependencies are present, but one of the dependencies has a newer modification date than myapp</li>
</ul><p>If one of the dependencies is missing and make doesn’t know how to make it (with another rule), make will error out.
Likewise if one of the steps produces an error, make will stop (unless specifically told to ignore the error).</p>

<p>Put more abstractly, make is just trying to satisfy its rules, which look like this:</p>

<pre><code class="language-make"><span class="nf">&lt;output&gt;</span><span class="o">:</span> <span class="m">&lt;dependencies&gt;</span>
    &lt;steps to make output from dependencies&gt;</code></pre>

<p>So, in these terms, make’s reasoning becomes clearer: to get <strong>output</strong>, I need <strong>dependencies</strong> and then I need to run <strong>steps to make output from dependencies</strong>. If the output already exists, make will do nothing. If the dependencies are lacking, make will try to make them if it has a rule for them. Please note that the part called output is often also called a target.</p>

<p>Many people will start protesting now, as they’ve seen “outputs” like <strong>install, uninstall, clean, etc.</strong> that don’t generate files called install, uninstall or clean. The thing is that these targets are special, and they are usually indicated as such by a special target called <strong>.PHONY</strong>. Make doesn’t need or want to know about the files generated by phony rules. Phony rules will always execute when called, multiple invocations to <code>make install</code> will, by default, do the same thing.</p>

<p>In the case above, <em>main.c</em> already exists, so it doesn’t need to be made. Lucky for us,
as we didn’t specify a rule to make <em>main.c</em>.</p>

<p>In most C projects, there’s a tendency to first generate the object (.o) files and then
generate the application from them. Doing this presents a nice opportunity to show multiple
rules working in tandem in make:</p>

<pre><code class="language-make"><span class="nf">myapp</span><span class="o">:</span> <span class="m">main.o</span>
    gcc main.o -o myapp -I.

<span class="nf">main.o</span><span class="o">:</span> <span class="m">main.c</span>
    gcc -c main.c -o main.o</code></pre>

<p>So now we’re first compiling to object files and then linking them together into
an executable, great! But what if we want to add another file? Suppose we have
another file called helper.c that we want to compile and link into our executable,
we could do this:</p>

<pre><code class="language-make"><span class="nf">myapp</span><span class="o">:</span> <span class="m">main.o helper.o</span>
    gcc main.o helper.o -o myapp -I.

<span class="nf">main.o</span><span class="o">:</span> <span class="m">main.c</span>
    gcc -c main.c -o main.o

<span class="nf">helper.o</span><span class="o">:</span> <span class="m">helper.c</span>
    gcc -c helper.c -o helper.o</code></pre>

<p>Note that we added helper.o as a new dependency for myapp, and that we specified
a rule for how to build helper.o from helper.c.</p>

<p>This works perfectly fine, but it’s getting kind of repetitive. Is there no way we
can fold the two last rules into one? Basically the only thing that differs
between them is the filename.</p>

<p>Sure, but that’s usually where it gets hairy for someone not accustomed to make.
Make has some special variables you can use inside of a rules to get rid of
the redundancy, but they’re very (very) poorly named.
The following four are pretty important, for starters:</p>

<ul>
<li>
<strong>$@</strong>: the name of the target file (the one before the colon)</li>
  <li>
<strong>$&lt;</strong>: the name of the first (or only) dependency (the first one after the colon)</li>
  <li>
<strong>$^</strong>: the names of all the dependencies (space separated)</li>
  <li>
<strong>$</strong>*: the stem (the bit which matches the % wildcard in a rule definition. (I’m not using this now, but it could be handy someday)</li>
</ul><p>These special variables, combined with wildcards (the <strong>%</strong> symbol in make), allow us
to compactly eliminate all the redundancy. An example will probably clarify it
better than a thousand words.</p>

<pre><code class="language-make"><span class="nf">myapp</span><span class="o">:</span> <span class="m">main.o helper.o</span>
    gcc <span class="nv">$^</span> -o <span class="nv">$@</span>

<span class="c"># when looking for something that ends in .o, look</span>
<span class="c"># for the same thing ending in .c and run gcc on it</span>
<span class="nf">%.o</span><span class="o">:</span> <span class="m">%.c</span>
    gcc -c <span class="nv">$&lt;</span></code></pre>

<p>There, redundancy solved! We only had to specify the name of the executable, and the object files
that are necessary to build the executable exactly once. If you expand
the variables in your head, it also looks quite logical.</p>

<p>Now there are some tiny tweaks that I do quite often to add
some commandline overridability:</p>

<pre><code class="language-make"><span class="c"># if $CC is not set, use gcc as a sensible default</span>
<span class="nv">CC</span> <span class="o">?=</span> gcc

<span class="c"># if $CFLAGS is not set, be very pedantic and compile</span>
<span class="c"># as C11, that should catch some common errors, also</span>
<span class="c"># fortify the source, which is a must for security.</span>
<span class="nv">CFLAGS</span> <span class="o">?=</span> -Wall <span class="se">\</span>
    -D_FORTIFY_SOURCE<span class="o">=</span>2 <span class="se">\</span>
    -Wextra -Wcast-align -Wcast-qual -Wpointer-arith <span class="se">\</span>
    -Waggregate-return -Wunreachable-code -Wfloat-equal <span class="se">\</span>
    -Wformat<span class="o">=</span>2 -Wredundant-decls -Wundef <span class="se">\</span>
    -Wdisabled-optimization -Wshadow -Wmissing-braces <span class="se">\</span>
    -Wstrict-aliasing<span class="o">=</span>2 -Wstrict-overflow<span class="o">=</span>5 -Wconversion <span class="se">\</span>
    -Wno-unused-parameter <span class="se">\</span>
    -pedantic -std<span class="o">=</span>c11

<span class="nf">myapp</span><span class="o">:</span> <span class="m">main.o helper.o</span>
    <span class="k">$(</span>CC<span class="k">)</span> <span class="nv">$^</span> -o <span class="nv">$@</span> <span class="k">$(</span>CFLAGS<span class="k">)</span>

<span class="c"># when looking for something that ends in .o, look</span>
<span class="c"># for the same thing ending in .c and run gcc on it</span>
<span class="nf">%.o</span><span class="o">:</span> <span class="m">%.c</span>
    <span class="k">$(</span>CC<span class="k">)</span> -c <span class="nv">$&lt;</span> <span class="k">$(</span>CFLAGS<span class="k">)</span></code></pre>

<p>That cranks the warnings up to 11, which is often
a good thing. It’s a good idea to turn the warnings on when
you start your project. Solving the deluge of warnings that
can come out of a mature project when going from no flags
to very pedantic is not fun.</p>

<p>Of course, there are some flags
that might be a little bit too pedantic. For example, when
doing game development it’s often useful to do some
<a href="http://graphics.stanford.edu/~seander/bithacks.html">bit twiddling</a>,
compare disparate number types and do dirty things with pointers.
In that case it might not be worth it or even possible to
prevent all the warnings by casting to the appropriate type. In
that case, feel free to disable some flags.</p>

<h3 id="debug-and-release-builds">Debug and release builds</h3>

<p>Quite often, you’d want to compile in debug mode but be
able to run</p>

<pre><code class="language-bash"><span class="nv">$ </span>make release</code></pre>

<p>When you’re done, spitting out a fully optimized and stripped
executable.</p>

<p>In make, there are often quite a few ways to achieve the
same thing, adding to the confusion. For debug and release
builds, I personally went for something really simple, expanding
our last example:</p>

<pre><code class="language-make"><span class="c"># if $CC is not set, use gcc as a sensible default</span>
<span class="nv">CC</span> <span class="o">?=</span> gcc

<span class="c"># if $CFLAGS is not set, be very pedantic and compile</span>
<span class="c"># as C11, that should catch some common errors, also</span>
<span class="c"># fortify the source, which is a must for security.</span>
<span class="nv">CFLAGS</span> <span class="o">?=</span> -Wall <span class="se">\</span>
    -D_FORTIFY_SOURCE<span class="o">=</span>2 <span class="se">\</span>
    -Wextra -Wcast-align -Wcast-qual -Wpointer-arith <span class="se">\</span>
    -Waggregate-return -Wunreachable-code -Wfloat-equal <span class="se">\</span>
    -Wformat<span class="o">=</span>2 -Wredundant-decls -Wundef <span class="se">\</span>
    -Wdisabled-optimization -Wshadow -Wmissing-braces <span class="se">\</span>
    -Wstrict-aliasing<span class="o">=</span>2 -Wstrict-overflow<span class="o">=</span>5 -Wconversion <span class="se">\</span>
    -Wno-unused-parameter <span class="se">\</span>
    -pedantic -std<span class="o">=</span>c11

<span class="nv">CFLAGS_DEBUG</span> <span class="o">:=</span> -g3 <span class="se">\</span>
    -O <span class="se">\</span>
    -DDEBUG

<span class="nv">CFLAGS_RELEASE</span> <span class="o">:=</span> -O2 <span class="se">\</span>
    -march<span class="o">=</span>native <span class="se">\</span>
    -mtune<span class="o">=</span>native <span class="se">\</span>
    -ftree-vectorize

<span class="c"># the default target is debug</span>
<span class="nf">all</span><span class="o">:</span> <span class="m">debug</span>

<span class="c"># when the target is debug,</span>
<span class="c"># add CFLAGS_DEBUG to CFLAGS</span>
<span class="nf">debug</span><span class="o">:</span> <span class="m">CFLAGS += $(CFLAGS_DEBUG)</span>
<span class="nf">debug</span><span class="o">:</span> <span class="m">myapp</span>

<span class="c"># when the target is release,</span>
<span class="c"># add CFLAGS_RELEASE to CFLAGS</span>
<span class="nf">release</span><span class="o">:</span> <span class="m">CFLAGS += $(CFLAGS_RELEASE)</span>
<span class="nf">release</span><span class="o">:</span> <span class="m">myapp</span>

<span class="nf">myapp</span><span class="o">:</span> <span class="m">main.o helper.o</span>
    <span class="k">$(</span>CC<span class="k">)</span> <span class="nv">$^</span> -o <span class="nv">$@</span> <span class="k">$(</span>CFLAGS<span class="k">)</span>

<span class="c"># when looking for something that ends in .o, look</span>
<span class="c"># for the same thing ending in .c and run gcc on it</span>
<span class="nf">%.o</span><span class="o">:</span> <span class="m">%.c</span>
    <span class="k">$(</span>CC<span class="k">)</span> -c <span class="nv">$&lt;</span> <span class="k">$(</span>CFLAGS<span class="k">)</span>

<span class="nf">.PHONY</span><span class="o">:</span> <span class="m">debug release</span></code></pre>

<p>We’re using <strong>target-specific variables</strong> to get
the job done. Notice that we added release and debug
as phony targets because they don’t generate files
called release and debug. Also note that both
target and debug have myapp as a dependency, so
they will both build the executable we want,
albeit with different flags.</p>

<h3 id="taking-into-account-differences-in-operating-systems-or-compilers">Taking into account differences in operating systems or compilers</h3>

<p>So now you’ve got your fancy project building in debug and release modes
and you’re really happy about it, but what when you’ve been developing
on OSX and want to build &amp; run it on Linux as well? Or what if
you want to support clang because of its awesome diagnostics?</p>

<p>With make, you can run some commands to find out what your environment
looks like and make choices based on that. The long and short of it
can be found on <a href="http://stackoverflow.com/questions/714100/os-detecting-makefile">stack overflow</a>.
I’ll repaste my own edited version here for posterity:</p>

<pre><code class="language-make"><span class="cp">ifeq ($(OS),Windows_NT)</span>
    CCFLAGS +<span class="o">=</span> -D WIN32
<span class="cp">    ifeq ($(PROCESSOR_ARCHITECTURE),AMD64)</span>
        CCFLAGS +<span class="o">=</span> -D AMD64
<span class="cp">    endif</span>
<span class="cp">    ifeq ($(PROCESSOR_ARCHITECTURE),x86)</span>
        CCFLAGS +<span class="o">=</span> -D IA32
<span class="cp">    endif</span>
<span class="cp">else</span>
<span class="c">    # tries to find the compiler name</span>
    CC_VERSION :<span class="o">=</span> <span class="k">$(</span>shell <span class="k">$(</span>CC<span class="k">)</span> --version | head -1 | cut -f1 -d<span class="s1">' '</span><span class="k">)</span>

<span class="c">    # tries to discern what UNIX-like OS we're running on</span>
    UNAME_S :<span class="o">=</span> <span class="k">$(</span>shell uname -s<span class="k">)</span>

<span class="cp">    ifeq ($(UNAME_S),Linux)</span>
        CCFLAGS +<span class="o">=</span> -D LINUX
<span class="cp">    endif</span>
<span class="cp">    ifeq ($(UNAME_S),Darwin)</span>
        CCFLAGS +<span class="o">=</span> -D OSX
<span class="cp">    endif</span>

<span class="cp">    ifneq (,$(findstring clang,$(CC_VERSION)))</span>
        CCFLAGS +<span class="o">=</span> -D CLANG

<span class="c">        # -pthread is not necessary when using Clang on Darwin</span>
<span class="cp">        ifneq ($(UNAME_S),Darwin)</span>
            CCFLAGS +<span class="o">=</span> -pthread
<span class="cp">        endif</span>
<span class="cp">    else</span>
        CCFLAGS +<span class="o">=</span> -D GCC
        CCFLAGS +<span class="o">=</span> -pthread

<span class="c">        # at least on OS X 10.7.5, the apple linker does </span>
<span class="c">        # not understand AVX and gcc uses it when you specify </span>
<span class="c">        # -mavx or -march=native and you have a CPU </span>
<span class="c">        # with AVX or better</span>
<span class="cp">        ifeq ($(UNAME_S),Darwin)</span>
            CCFLAGS +<span class="o">=</span> -mno-avx
<span class="cp">        endif</span>
<span class="cp">    endif</span>

    UNAME_P :<span class="o">=</span> <span class="k">$(</span>shell uname -m<span class="k">)</span>

<span class="cp">    ifeq ($(UNAME_P),x86_64)</span>
        CCFLAGS +<span class="o">=</span> -D AMD64
<span class="cp">    endif</span>
<span class="cp">    ifneq ($(filter %86,$(UNAME_P)),)</span>
        CCFLAGS +<span class="o">=</span> -D IA32
<span class="cp">    endif</span>
<span class="cp">    ifneq ($(filter arm%,$(UNAME_P)),)</span>
        CCFLAGS +<span class="o">=</span> -D ARM
<span class="cp">    endif</span>
<span class="cp">endif</span></code></pre>

<p>It adds define flags so that whenever necessary, it can be used
to partially define blocks of code based on OS, CPU or compiler.
Of course I should note that this is best used when there are no
obvious alternatives, nobody likes <code>#ifdef</code> soup.</p>

<p>By the way, I was bashing autotools earlier for being a mess and creating unreadable
makefiles, but it remains an oft-used toolset for cross-platform building.
Why is that? Inertia? Well… yes and no. Sometimes building on many (very) different
operating systems becomes quite a chore, and autotools makes some of that, well,
easier. It was built long ago for the express purpose of generating cross-platform
makefiles, which is also why it panders to the lowest common denominator by
not using any of the newer features that modern make has.</p>

<p>There are <a href="http://cgit.freedesktop.org/libva/">a lot</a> of
<a href="http://cgit.freedesktop.org/xorg/driver/xf86-video-intel/">examples</a> of
<a href="http://www.mplayerhq.hu/design7/news.html">projects</a>
using autotools to great effect, even maintaining almost readable autoconf.ac files.
One could copy and paste given a bit of effort and after a while you could be an
autotools adept too (not a wizard, I suppose there are only 3 people in the world like that).</p>

<p>A decent alternative is <a href="http://www.cmake.org/">cmake</a>, which tends to be a bit more readable, and can generate
makefiles on UNIX platforms and visual studio project files on windows, if that’s
your thing.</p>

<p>But when your project exhibits just slight differences between OS or compiler toolchains,
there’s no need to take the plunge and migrate to autotools, cmake or anything else just yet.
We can make do with plain make, and still keep it quite readable.</p>

<p>Oh, and there’s another thing cmake, autotools and its ilk are pretty
good at: finding dependencies. This used to be much
more important and difficult to do with make. But thanks to the rise of
<a href="http://www.freedesktop.org/wiki/Software/pkg-config/">pkg-config</a>, I
find that plain make will do fine for smaller projects.</p>

<div class="footnotes">
  <ol>
<li id="fn:1">
      <p>Sweet nostalgia, Dev-C++ was my first real IDE, it helped me form my knowledge of C by being easy to use yet not having auto-completion, which cemented a lot of important functions in my muscle memory. <a href="#fnref:1" class="reversefootnote">↩</a></p>
    </li>
    <li id="fn:2">
      <p>Note that I’m describing makefiles for a C project here, but any developer worth her salt should be able to see that it’s applicable to much more. In fact I use make in combination with <a href="https://github.com/jordansissel/fpm">fpm</a> to build .deb files for debian/ubuntu, all I have to do is run <code>make deb</code>. <a href="#fnref:2" class="reversefootnote">↩</a></p>
    </li>
  </ol>
</div>
        </article>

        <p>Tags: <a href="/tag/unix" rel="tag">unix</a>, <a href="/tag/c" rel="tag">c</a>, <a href="/tag/make" rel="tag">make</a>, <a href="/tag/linux" rel="tag">linux</a>, <a href="/tag/osx" rel="tag">osx</a></p>
    </div>
</div>
        <div id="sidebar">
            <h2>Nicolas Hillegeer</h2>
            <ul>
                <li><a href="/">Blog</a></li>
                <li><a href="/archive">Archive</a></li>
                <li><a href="/cv-alt/cv.pdf">Curriculum Vitae / Résumé</a></li>
                <li><a href="/contact">About Me &amp; Contact</a></li>
            </ul>
            <h2>Online presence</h2>
            <ul>
                <li><a href="https://github.com/Aktau/">Github</a></li>
                <li><a href="https://twitter.com/alazyleopard">Twitter</a></li>
                <li><a href="http://stackoverflow.com/users/558819/aktau">Stack Overflow</a></li>
                <li><a href="https://soundcloud.com/aktau">Soundcloud</a></li>
            </ul>
            <!--
            <h2>Tags</h2>
            <ul>
                
                <li><a href="/tag/sdl">sdl (1)</a></li>
                
                <li><a href="/tag/game-engine">game-engine (1)</a></li>
                
                <li><a href="/tag/open-source">open-source (1)</a></li>
                
                <li><a href="/tag/ffmpeg">ffmpeg (1)</a></li>
                
                <li><a href="/tag/github">github (2)</a></li>
                
                <li><a href="/tag/github-release">github-release (1)</a></li>
                
                <li><a href="/tag/gofinance">gofinance (1)</a></li>
                
                <li><a href="/tag/golang">golang (1)</a></li>
                
                <li><a href="/tag/cross-compiling">cross-compiling (1)</a></li>
                
                <li><a href="/tag/introduction">introduction (1)</a></li>
                
                <li><a href="/tag/nanoc">nanoc (1)</a></li>
                
                <li><a href="/tag/pygments">pygments (1)</a></li>
                
                <li><a href="/tag/unix">unix (1)</a></li>
                
                <li><a href="/tag/c">c (1)</a></li>
                
                <li><a href="/tag/make">make (1)</a></li>
                
                <li><a href="/tag/linux">linux (1)</a></li>
                
                <li><a href="/tag/osx">osx (1)</a></li>
                
            </ul>
            -->
        </div>

        <script>
            var pluginUrl = '//www.google-analytics.com/plugins/ga/inpage_linkid.js';
            var _gaq=[['_setAccount','UA-37726728-1'],['_trackPageview'], ['_require', 'inpage_linkid', pluginUrl]];
            (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
            g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
            s.parentNode.insertBefore(g,s)}(document,'script'));
        </script>
    </body>
</html>
